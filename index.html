<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magical Hangul World</title>
    <!-- 구글 폰트: 부드러운 느낌의 'Jua' (배달의민족 주아체)와 'Gowun Dodum' (고운돋움) -->
    <link href="https://fonts.googleapis.com/css2?family=Jua&family=Gowun+Dodum&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            /* 한국적인 느낌이 나는 은은한 먹색/남색 배경 */
            background: radial-gradient(circle at center, #2c3e50 0%, #000000 100%);
            overflow: hidden;
            font-family: 'Gowun Dodum', sans-serif;
            height: 100vh;
            color: white;
        }

        /* Canvas for Particle System */
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* Overlay for "Click to Start" */
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 100;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            cursor: pointer;
            backdrop-filter: blur(8px);
            transition: opacity 0.8s ease;
        }

        #overlay h1 {
            font-family: 'Jua', sans-serif;
            font-size: 3rem;
            color: #f1f2f6;
            margin-bottom: 20px;
            animation: float 3s ease-in-out infinite;
        }

        #overlay p {
            font-size: 1.2rem;
            color: #a4b0be;
        }

        /* Date/Time Display */
        #datetime {
            position: fixed;
            bottom: 30px;
            right: 30px;
            z-index: 10;
            padding: 20px 30px;
            background: rgba(255, 255, 255, 0.03);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            text-align: right;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            transition: transform 0.3s ease;
            pointer-events: none;
            user-select: none;
        }

        #datetime:hover {
            transform: scale(1.02);
            background: rgba(255, 255, 255, 0.08);
        }

        .time {
            font-family: 'Jua', sans-serif;
            font-size: 2rem;
            color: #ffeaa7;
            /* 한국적인 연한 금색 */
            display: block;
            margin-bottom: 5px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .date {
            font-size: 1rem;
            opacity: 0.7;
            color: #dfe6e9;
        }

        @keyframes float {
            0% {
                transform: translateY(0px);
            }

            50% {
                transform: translateY(-10px);
            }

            100% {
                transform: translateY(0px);
            }
        }

        #greeting {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            z-index: 10;
            font-family: 'Jua', sans-serif;
            font-size: 2rem;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            pointer-events: none;
            user-select: none;
        }
    </style>
</head>

<body>

    <div id="overlay">
        <h1>화면을 클릭하여 시작하세요</h1>
        <p>소리와 함께 특별한 경험을 즐겨보세요</p>
    </div>

    <div id="greeting">How are you feeling today?</div>

    <canvas id="canvas1"></canvas>

    <div id="datetime">
        <span class="time" id="timeDisplay">00:00</span>
        <span class="date" id="dateDisplay">YYYY-MM-DD</span>
    </div>

    <script>
        const canvas = document.getElementById('canvas1');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let particleArray = [];
        let adjustX = 0;
        let adjustY = 0;

        // --- Cherry Blossom Effect ---
        let petalArray = [];
        const petalImage = new Image();
        // 간단한 벚꽃잎 모양을 Base64로 생성 (외부 이미지 없이 작동)
        petalImage.src = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMCAzMCI+PHBhdGggZD0iTTE1IDBDMTUgMCAyMCAxMCAyMCAxNUMyMCAyMCAxNSAzMCAxNSAzMEMxNSAzMCAxMCAyMCAxMCAxNUMxMCAxMCAxNSAwIDE1IDBaIiBmaWxsPSIjZmZjM2UzIiBvcGFjaXR5PSIwLjgiLz48L3N2Zz4=';

        class Petal {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height - canvas.height;
                this.size = Math.random() * 15 + 10;
                this.speed = Math.random() * 2 + 1;
                this.angle = Math.random() * 360;
                this.spin = Math.random() < 0.5 ? 1 : -1;
                this.opacity = Math.random() * 0.5 + 0.3;
            }
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle * Math.PI / 180);
                ctx.globalAlpha = this.opacity;
                ctx.drawImage(petalImage, -this.size / 2, -this.size / 2, this.size, this.size);
                ctx.restore();
            }
            update() {
                this.y += this.speed;
                this.x += Math.sin(this.angle * Math.PI / 90) * 0.5; // 살랑거리는 움직임
                this.angle += this.spin;

                if (this.y > canvas.height) {
                    this.y = -20;
                    this.x = Math.random() * canvas.width;
                }
            }
        }

        function initPetals() {
            petalArray = [];
            let numberOfPetals = 40; // 벚꽃잎 개수
            for (let i = 0; i < numberOfPetals; i++) {
                petalArray.push(new Petal());
            }
        }


        // --- Web Audio API (가야금/거문고 스타일 합성) ---
        let audioCtx;
        let isAudioInitialized = false;
        let lastPlayedTime = 0;

        // 국악 5음계 (황종, 태주, 중려, 임종, 남려) - 근사치 주파수 (Eb Major Pentatonic 느낌)
        const scale = [
            261.63, // C4 (중)
            293.66, // D4 (임)
            329.63, // E4 (무)
            392.00, // G4 (황)
            440.00, // A4 (태)
            523.25, // C5
            587.33  // D5
        ];

        function initAudio() {
            if (isAudioInitialized) return;
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            audioCtx = new AudioContext();
            isAudioInitialized = true;
        }

        // 현악기 퉁기는 소리 (Plucked String) 합성
        function playTraditionalSound(intensity) {
            if (!isAudioInitialized) return;

            // 소리 너무 자주 나지 않게 제한 (Throttle)
            const now = audioCtx.currentTime;
            if (now - lastPlayedTime < 0.1) return;
            lastPlayedTime = now;

            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            const filterNode = audioCtx.createBiquadFilter();

            // 랜덤한 음계 선택
            const noteIndex = Math.floor(Math.random() * scale.length);
            const freq = scale[noteIndex];

            // 1. 오실레이터 설정 (Sine 파형으로 변경하여 부드러운 소리 - 오르골/하프 느낌)
            oscillator.type = 'sine';
            oscillator.frequency.value = freq;

            // 2. 필터 설정 (더 부드럽게 깎음)
            filterNode.type = 'lowpass';
            filterNode.frequency.setValueAtTime(800, now); // 시작 주파수를 낮춤
            filterNode.frequency.linearRampToValueAtTime(200, now + 1.5);

            // 3. 볼륨(Gain) 엔벨로프 - 부드러운 시작과 긴 여운
            const volume = Math.min(intensity * 0.5, 0.2); // 전체 볼륨을 살짝 낮춤
            gainNode.gain.setValueAtTime(0, now);
            gainNode.gain.linearRampToValueAtTime(volume, now + 0.15); // Attack을 0.15초로 늘려 아주 부드럽게
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + 2.5); // 아주 긴 여운

            // 연결: Osc -> Filter -> Gain -> Destination
            oscillator.connect(filterNode);
            filterNode.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.start(now);
            oscillator.stop(now + 1.5);
        }

        // --- Clock Logic ---
        function updateClock() {
            const now = new Date();
            const timeString = now.toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit', hour12: true }); // 오전/오후 HH:MM
            const dateString = now.toLocaleDateString('ko-KR', {
                weekday: 'long',
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            });

            document.getElementById('timeDisplay').textContent = timeString;
            document.getElementById('dateDisplay').textContent = dateString;
        }
        setInterval(updateClock, 1000);
        updateClock();

        // --- Interaction ---
        const mouse = {
            x: null,
            y: null,
            radius: 120 // 반경을 조금 더 넓힘
        }

        window.addEventListener('mousemove', function (event) {
            mouse.x = event.x;
            mouse.y = event.y;

            // 마우스가 빠르게 움직이면 소리 트리거
            // (간단한 구현을 위해 무조건 움직임이 있으면 확률적으로 소리 재생)
            if (isAudioInitialized && Math.random() < 0.1) {
                // playTraditionalSound(0.5); // 너무 시끄러울 수 있어서 파티클 충돌시 재생으로 변경
            }
        });

        const overlay = document.getElementById('overlay');
        overlay.addEventListener('click', () => {
            initAudio();
            overlay.style.opacity = '0';
            setTimeout(() => {
                overlay.style.display = 'none';
            }, 800);
            if (audioCtx && audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        });

        // --- Particle System ---

        class Particle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.originX = x;
                this.originY = y;
                this.size = 2;
                this.baseColor = 'rgba(255,255,255,0.8)'; // 부드러운 흰색
                this.activeColor = '#ff7675'; // 벚꽃색과 어울리는 분홍빛 포인트
                this.color = this.baseColor;
                this.vx = 0;
                this.vy = 0;
                this.friction = 0.92; // 마찰을 줄여서 좀 더 둥둥 떠다니는 느낌
                this.ease = 0.08; // 복귀 속도를 부드럽게
                this.dx = 0;
                this.dy = 0;
                this.distance = 0;
                this.force = 0;
                this.angle = 0;
                this.triggeredSound = false; // 소리 중복 재생 방지
            }
            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.closePath();
                ctx.fill();
            }
            update() {
                this.dx = mouse.x - this.x;
                this.dy = mouse.y - this.y;
                this.distance = Math.sqrt(this.dx * this.dx + this.dy * this.dy);

                if (this.distance < mouse.radius) {
                    this.force = -mouse.radius / this.distance;
                    this.angle = Math.atan2(this.dy, this.dx);

                    let pushX = Math.cos(this.angle) * this.force * 6;
                    let pushY = Math.sin(this.angle) * this.force * 6;

                    this.vx += pushX;
                    this.vy += pushY;
                    this.color = this.activeColor;

                    // 파티클이 강하게 튕겨나갈 때만 소리 재생 시도
                    if (!this.triggeredSound && Math.abs(pushX) + Math.abs(pushY) > 2) {
                        playTraditionalSound(Math.abs(pushX));
                        this.triggeredSound = true;
                    }

                } else {
                    // 복귀
                    if (this.color !== this.baseColor) {
                        this.color = this.baseColor;
                    }
                    this.triggeredSound = false; // 리셋
                }

                this.vx += (this.originX - this.x) * this.ease;
                this.vy += (this.originY - this.y) * this.ease;

                this.vx *= this.friction;
                this.vy *= this.friction;

                this.x += this.vx;
                this.y += this.vy;
            }
        }

        // --- Morphing Text Logic ---
        const messages = ['Hello World', 'Happy Day', '건강하세요', '사랑합니다'];
        let currentMessageIndex = 0;
        let frameCounter = 0;
        const morphInterval = 300; // 약 5초마다 변신 (60fps 기준)

        function init(text = messages[currentMessageIndex]) {
            // 기존 파티클 위치 정보를 저장하여 부드러운 이동 준비 (선택적)
            particleArray = [];

            // 폰트 설정
            let fontSize = Math.min(canvas.width / 8, 200);
            ctx.font = `normal ${fontSize}px 'Jua'`;

            const textMetrics = ctx.measureText(text);
            const textWidth = textMetrics.width;

            adjustX = (canvas.width / 2) - (textWidth / 2);
            adjustY = (canvas.height / 2) + (fontSize / 3);

            // 텍스트를 그려서 데이터 추출
            ctx.clearRect(0, 0, canvas.width, canvas.height); // 임시 캔버스 클리어
            ctx.fillStyle = 'white';
            ctx.fillText(text, adjustX, adjustY);

            const gap = 6; // 성능을 위해 간격을 조금 넓힘
            const textData = ctx.getImageData(0, 0, canvas.width, canvas.height);

            // 메인 캔버스 클리어 (텍스트 흔적 지움)
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            for (let y = 0; y < canvas.height; y += gap) {
                for (let x = 0; x < canvas.width; x += gap) {
                    const alpha = textData.data[(y * 4 * textData.width) + (x * 4) + 3];
                    if (alpha > 128) {
                        particleArray.push(new Particle(x, y));
                    }
                }
            }
        }

        function animate() {
            // 잔상 효과를 위해 투명도 있는 사각형으로 덮기
            ctx.fillStyle = 'rgba(20, 25, 40, 0.15)'; // 배경색과 유사하지만 투명하게
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            particleArray.forEach(particle => {
                particle.draw();
                particle.update();
            });

            // 벚꽃 그리기
            petalArray.forEach(petal => {
                petal.draw();
                petal.update();
            });

            // 글자 변신 타이머
            frameCounter++;
            if (frameCounter >= morphInterval) {
                frameCounter = 0;
                currentMessageIndex = (currentMessageIndex + 1) % messages.length;

                // 화면 전체를 지우지 않고 자연스럽게 넘어가기 위해 init 호출
                // 새 글자 모양으로 파티클 재생성
                init(messages[currentMessageIndex]);
            }

            requestAnimationFrame(animate);
        }

        window.addEventListener('resize', function () {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            init(messages[currentMessageIndex]);
            initPetals(); // 벚꽃도 리셋
        });

        window.addEventListener('mouseout', function () {
            mouse.x = undefined;
            mouse.y = undefined;
        });

        // 폰트 로드 대기 후 초기화 (폰트 미적용 방지)
        document.fonts.ready.then(function () {
            init(messages[0]);
            initPetals();
            animate();
        });

    </script>
</body>

</html>